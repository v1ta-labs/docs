---
title: marginfi Integration
description: How v1ta integrates with marginfi for flash liquidity and composable credit
icon: Link
---

import { Card, Cards } from 'fumadocs-ui/components/card';

import { Callout } from 'fumadocs-ui/components/callout';

# marginfi Integration

v1ta is built on top of marginfi, Solana's leading DeFi protocol, to provide flash liquidity and composable credit.

## What is marginfi?

marginfi is a decentralized lending protocol on Solana that provides:

- **Flash Loans**: Borrow and repay within a single transaction
- **Cross-Margin**: Use assets across multiple protocols
- **Composable Credit**: Build credit-based applications
- **High Capital Efficiency**: Optimal utilization of assets

## How v1ta Uses marginfi

### 1. Flash Liquidity

v1ta uses marginfi's flash loan capabilities for instant liquidity:

**Use Cases:**
- Liquidation bots can flash borrow VUSD to liquidate positions
- Arbitragers can flash borrow to exploit price discrepancies
- Position managers can rebalance without upfront capital

**Example: Flash Liquidation**
```typescript
import { MarginfiClient } from '@mrgnlabs/marginfi-client-v2';
import { V1taClient } from './v1ta-client';

async function flashLiquidate(targetPosition: PublicKey) {
  const marginfi = new MarginfiClient(/* ... */);
  const v1ta = new V1taClient(/* ... */);

  // 1. Flash borrow VUSD from marginfi
  // 2. Liquidate position in v1ta
  // 3. Receive SOL collateral
  // 4. Swap SOL for VUSD
  // 5. Repay flash loan
  // 6. Keep profit

  await marginfi.flashLoan(
    vusdAmount,
    async (vusd) => {
      // Liquidate the position
      await v1ta.liquidate(targetPosition);

      // Swap received SOL for VUSD
      const vusdReceived = await swapSolToVusd(/* ... */);

      // Return borrowed amount plus fee
      return vusdReceived;
    }
  );
}
```

### 2. Composable Credit

VUSD can be used as collateral in marginfi lending pools:

**Benefits:**
- Earn yield on borrowed VUSD
- Use VUSD to borrow other assets
- Participate in DeFi strategies without selling

**Example: Lending VUSD**
```typescript
async function lendVusd(amount: number) {
  const marginfi = new MarginfiClient(/* ... */);

  // Supply VUSD to marginfi
  await marginfi.deposit(VUSD_MINT, amount);

  // VUSD now earning yield
  // Can be used as collateral for other borrows
}
```

### 3. Cross-Protocol Positions

Manage positions across both protocols:

**Strategy Example:**
1. Open v1ta CDP with SOL collateral
2. Borrow VUSD at 110% CR
3. Supply VUSD to marginfi
4. Borrow additional assets from marginfi
5. Total capital efficiency multiplied

## Integration Architecture

The user's wallet connects to both v1ta and marginfi, with v1ta providing CDP functionality and marginfi providing VUSD as collateral for other borrows.

## Code Examples

### Complete Integration Example

```typescript
import { Connection, PublicKey, Keypair } from '@solana/web3.js';
import { MarginfiClient } from '@mrgnlabs/marginfi-client-v2';
import { AnchorProvider, Program } from '@coral-xyz/anchor';

class V1taMarginfiIntegration {
  private v1taProgram: Program;
  private marginfiClient: MarginfiClient;

  constructor(
    connection: Connection,
    wallet: Wallet
  ) {
    // Initialize v1ta
    const provider = new AnchorProvider(connection, wallet, {});
    this.v1taProgram = new Program(V1TA_IDL, V1TA_PROGRAM_ID, provider);

    // Initialize marginfi
    this.marginfiClient = MarginfiClient.fetch(
      {},
      wallet,
      connection
    );
  }

  /**
   * Open v1ta position and supply VUSD to marginfi
   */
  async openAndSupply(
    solCollateral: number,
    vusdToBorrow: number
  ) {
    // 1. Open v1ta position
    const tx1 = await this.v1taProgram.methods
      .openPosition(
        new BN(solCollateral),
        new BN(vusdToBorrow)
      )
      .accounts({
        // ... accounts
      })
      .rpc();

    console.log('Position opened:', tx1);

    // 2. Supply VUSD to marginfi
    const marginfiAccount = await this.marginfiClient.createMarginfiAccount();

    await marginfiAccount.deposit(
      vusdToBorrow,
      this.marginfiClient.getBankByMint(VUSD_MINT)
    );

    console.log('VUSD supplied to marginfi');
  }

  /**
   * Use flash loan to liquidate and profit
   */
  async flashLiquidatePosition(targetPosition: PublicKey) {
    const marginfiAccount = await this.marginfiClient.getMarginfiAccount();

    // Calculate required VUSD
    const positionData = await this.v1taProgram.account.position.fetch(
      targetPosition
    );
    const requiredVusd = positionData.debt;

    // Flash borrow and liquidate
    await marginfiAccount.flashLoan({
      amount: requiredVusd,
      callback: async (borrowedVusd) => {
        // Liquidate v1ta position
        await this.v1taProgram.methods
          .liquidate()
          .accounts({
            position: targetPosition,
            // ... other accounts
          })
          .rpc();

        // We received SOL plus 0.5% bonus
        // Swap SOL back to VUSD to repay loan
        const vusdFromSwap = await this.swapSolToVusd(/* ... */);

        return vusdFromSwap; // Must be at least borrowed amount
      }
    });
  }

  /**
   * Complex strategy: Leveraged yield farming
   */
  async leveragedYieldFarm(initialSol: number) {
    // 1. Open max v1ta position
    const maxVusd = (initialSol * SOL_PRICE) / 1.105;

    await this.v1taProgram.methods
      .openPosition(
        new BN(initialSol),
        new BN(maxVusd)
      )
      .rpc();

    // 2. Supply VUSD to marginfi
    const marginfiAccount = await this.marginfiClient.getMarginfiAccount();
    await marginfiAccount.deposit(maxVusd, VUSD_BANK);

    // 3. Borrow another asset (e.g., USDC) from marginfi
    await marginfiAccount.borrow(
      maxVusd * 0.8, // 80% of VUSD value
      USDC_BANK
    );

    // 4. Use borrowed USDC in yield strategies
    // ...

    // Result: Earning yield on multiple layers
  }

  private async swapSolToVusd(amount: number): Promise<number> {
    // Implement swap via Jupiter or other DEX
    return 0;
  }
}
```

### Monitoring Integration

```typescript
/**
 * Monitor positions across both protocols
 */
class CrossProtocolMonitor {
  async getCompletePosition(user: PublicKey) {
    // Get v1ta position
    const [v1taPosition] = getPositionPDA(user);
    const v1taData = await v1taProgram.account.position.fetch(v1taPosition);

    // Get marginfi position
    const marginfiAccount = await marginfiClient.getMarginfiAccountByUser(user);
    const marginfiData = await marginfiAccount.fetch();

    return {
      v1ta: {
        collateral: v1taData.collateral,
        debt: v1taData.debt,
        cr: this.calculateCR(v1taData)
      },
      marginfi: {
        supplied: marginfiData.balances.VUSD || 0,
        borrowed: marginfiData.borrows,
        health: marginfiAccount.getHealthFactor()
      },
      combined: {
        totalVusd: v1taData.debt + (marginfiData.balances.VUSD || 0),
        effectiveLeverage: this.calculateLeverage(v1taData, marginfiData)
      }
    };
  }
}
```

## marginfi Keeper Integration

v1ta can integrate with marginfi's keeper network for automated liquidations.

### Keeper Bot Example

```typescript
import { MarginfiClient } from '@mrgnlabs/marginfi-client-v2';

class V1taMarginfiKeeper {
  private marginfi: MarginfiClient;
  private v1ta: Program;

  async monitorAndLiquidate() {
    // Monitor all v1ta positions
    const positions = await this.getAllPositions();

    for (const position of positions) {
      const cr = await this.getCollateralRatio(position);

      if (cr < 110) {
        // Position is liquidatable
        await this.flashLiquidateViaMarginfi(position);
      }
    }
  }

  private async flashLiquidateViaMarginfi(position: PublicKey) {
    const account = await this.marginfi.getMarginfiAccount();

    // Use marginfi flash loan for zero-capital liquidation
    await account.flashLoan({
      amount: position.debt,
      callback: async () => {
        // Liquidate in v1ta
        await this.v1ta.methods.liquidate().accounts({
          position,
          // ...
        }).rpc();

        // Convert received SOL to VUSD
        return await this.convertSolToVusd();
      }
    });
  }
}
```

## Benefits of Integration

### For Users

1. **Higher Capital Efficiency**
   - Borrow from v1ta at 110% CR
   - Use VUSD in marginfi for additional borrowing
   - Stack yields across protocols

2. **Flash Liquidity Access**
   - Rebalance positions without selling
   - Arbitrage opportunities
   - Capital-efficient liquidations

3. **Composable Strategies**
   - Create complex DeFi positions
   - Automated yield optimization
   - Cross-protocol risk management

### For Developers

1. **Flash Loan Infrastructure**
   - Build liquidation bots without capital
   - Arbitrage opportunities
   - MEV extraction

2. **Composable Building Blocks**
   - Combine v1ta and marginfi in single transactions
   - Create new financial primitives
   - Build on proven infrastructure

3. **Shared Liquidity**
   - Access to marginfi's deep liquidity
   - Better execution for large operations
   - Reduced slippage

## Best Practices

<Callout type="info">
  Follow these guidelines for safe cross-protocol usage:
</Callout>

1. **Understand Combined Risk**
   - Monitor health factors on both protocols
   - Account for liquidation risk on each
   - Maintain buffers on all positions

2. **Test Thoroughly**
   - Test integrations on devnet first
   - Simulate edge cases
   - Have emergency procedures

3. **Monitor Continuously**
   - Track positions across both protocols
   - Set up alerts for health factors
   - Have automated rebalancing

4. **Account for Fees**
   - v1ta fees: 0.5% borrow, 5% liquidation
   - marginfi fees: Variable based on utilization
   - Gas costs for cross-protocol operations

## Security Considerations

### Flash Loan Security

When using flash loans:

1. **Validate All State Changes**: Ensure expected outcomes
2. **Handle Failures Gracefully**: Flash loan must complete atomically
3. **Check Slippage**: Swaps must have reasonable slippage limits
4. **Monitor MEV**: Be aware of MEV extraction risks

### Cross-Protocol Risk

1. **Oracle Dependency**: Both protocols use oracles (Pyth)
2. **Liquidation Cascades**: Liquidation in one can affect the other
3. **Smart Contract Risk**: Exposure to both protocols' bugs

## Future Enhancements

Planned improvements to the integration:

1. **Direct Protocol-to-Protocol Communication**
   - Cross-program invocations (CPI)
   - Atomic operations across both protocols
   - Shared state for better efficiency

2. **Unified Liquidation System**
   - marginfi keepers can liquidate v1ta positions
   - Shared liquidation rewards
   - More robust liquidation infrastructure

3. **Yield Optimization**
   - Auto-compound VUSD yields in marginfi
   - Automated rebalancing based on rates
   - Risk-adjusted position management

## Resources

- [marginfi Documentation](https://docs.marginfi.com)
- [marginfi SDK](https://github.com/mrgnlabs/marginfi-v2)
- [Integration Examples](https://github.com/v1ta-labs/examples)

## Next Steps

<Cards>
  <Card
    title="Drift Integration"
    description="Use VUSD in Drift perps and spot markets"
    href="/docs/integrations/drift"
  />
  <Card
    title="Developer Guide"
    description="Build your own integrations"
    href="/docs/developer/getting-started"
  />
</Cards>
